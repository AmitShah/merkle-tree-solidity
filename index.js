'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkProofOrderedSolidityFactory = exports.checkProofSolidityFactory = exports.merkleRoot = exports.checkProofOrdered = exports.checkProof = undefined;

var _ethereumjsUtil = require('ethereumjs-util');

// Expects elements to be Buffers of length 32
// empty string elements will be removed prior to the buffer check
// by default, order is not preserved
function MerkleTree(elements, preserveOrder) {
  if (!(this instanceof MerkleTree)) {
    return new MerkleTree(elements, preserveOrder);
  }

  this.elements = Array.from(new Set(elements.filter(a => a)));
  if (this.elements.some(e => !(e.length == 32 && Buffer.isBuffer(e)))) {
    throw new Error('elements must be 32 byte buffers');
  }
  this.preserveOrder = !!preserveOrder;
  if (!this.preserveOrder) {
    this.elements.sort(Buffer.compare);
  }
  this.layers = getLayers(this.elements, this.preserveOrder);
} // https://github.com/raiden-network/raiden/blob/master/raiden/mtree.py
// Create a merkle root from a list of elements
// Elements are assumed to be 32 bytes hashes (Buffers)
//  (but may be expressed as 0x prefixed hex strings of length 66)
// The bottom layer of the tree (leaf nodes) are the elements
// All layers above are combined hashes of the element pairs

// Two strategies for creating tree and checking proofs (preserveOrder flag)
// 1. raiden - sort the leaves of the tree, and also sort each pair of
//    pre-images, which allows you to verify the proof without the index
// 2. storj - preserve the order of the leaves and pairs of pre-images, and use
//    the index to verify the proof

// The MerkleTree is a 2d array of layers
// [ elements, combinedHashes1, combinedHashes2, ... root]
// root is a length 1 array

MerkleTree.prototype.getRoot = function () {
  return this.layers[this.layers.length - 1][0];
};

MerkleTree.prototype.getProof = function (element, hex) {
  const index = getBufIndex(element, this.elements);
  if (index == -1) {
    throw new Error('element not found in merkle tree');
  }
  return getProof(index, this.layers, hex);
};

const checkProofOrdered = function checkProofOrdered(proof, root, element, index) {
  // use the index to determine the node ordering
  // index ranges 1 to n

  let tempHash = element;

  for (let i = 0; i < proof.length; i++) {
    let remaining = proof.length - i;

    // we don't assume that the tree is padded to a power of 2
    // if the index is odd then the proof will start with a hash at a higher
    // layer, so we have to adjust the index to be the index at that layer
    while (remaining && index % 2 === 1 && index > Math.pow(2, remaining)) {
      index = Math.round(index / 2);
    }

    if (index % 2 === 0) {
      tempHash = combinedHash(proof[i], tempHash, true);
    } else {
      tempHash = combinedHash(tempHash, proof[i], true);
    }
    index = Math.round(index / 2);
  }

  return tempHash.equals(root);
};

const checkProof = function checkProof(proof, root, element) {
  return root.equals(proof.reduce((hash, pair) => {
    return combinedHash(hash, pair);
  }, element));
};

const merkleRoot = function merkleRoot(elements, preserveOrder) {
  return new MerkleTree(elements, preserveOrder).getRoot();
};

// converts buffers from MerkleRoot functions into hex strings
// merkleProof is the contract abstraction for MerkleProof.sol
const checkProofSolidityFactory = function checkProofSolidityFactory(checkProofContractMethod) {
  return function (proof, root, hash) {
    proof = '0x' + proof.map(e => e.toString('hex')).join('');
    root = bufToHex(root);
    hash = bufToHex(hash);
    return checkProofContractMethod(proof, root, hash);
  };
};

const checkProofOrderedSolidityFactory = function checkProofOrderedSolidityFactory(checkProofOrderedContractMethod) {
  return function (proof, root, hash, index) {
    proof = '0x' + proof.map(e => e.toString('hex')).join('');
    root = bufToHex(root);
    hash = bufToHex(hash);
    return checkProofOrderedContractMethod(proof, root, hash, index);
  };
};

exports.default = MerkleTree;
exports.checkProof = checkProof;
exports.checkProofOrdered = checkProofOrdered;
exports.merkleRoot = merkleRoot;
exports.checkProofSolidityFactory = checkProofSolidityFactory;
exports.checkProofOrderedSolidityFactory = checkProofOrderedSolidityFactory;


function combinedHash(first, second, preserveOrder) {
  if (!second) {
    return first;
  }
  if (!first) {
    return second;
  }
  if (preserveOrder) {
    return (0, _ethereumjsUtil.sha3)(bufJoin(first, second));
  } else {
    return (0, _ethereumjsUtil.sha3)(bufSortJoin(first, second));
  }
}

function getNextLayer(elements, preserveOrder) {
  return elements.reduce((layer, element, index, arr) => {
    if (index % 2 == 0) {
      layer.push(combinedHash(element, arr[index + 1], preserveOrder));
    }
    return layer;
  }, []);
}

function getLayers(elements, preserveOrder) {
  if (elements.length == 0) {
    return [['']];
  }
  const layers = [];
  layers.push(elements);
  while (layers[layers.length - 1].length > 1) {
    layers.push(getNextLayer(layers[layers.length - 1], preserveOrder));
  }
  return layers;
}

function getProof(index, layers, hex) {
  const proof = layers.reduce((proof, layer) => {
    let pair = getPair(index, layer);
    if (pair) {
      proof.push(pair);
    }
    index = Math.floor(index / 2);
    return proof;
  }, []);
  if (hex) {
    return '0x' + proof.map(e => e.toString('hex')).join('');
  } else {
    return proof;
  }
}

function getPair(index, layer) {
  let pairIndex = index % 2 ? index - 1 : index + 1;
  if (pairIndex < layer.length) {
    return layer[pairIndex];
  } else {
    return null;
  }
}

function getBufIndex(element, array) {
  for (let i = 0; i < array.length; i++) {
    if (element.equals(array[i])) {
      return i;
    }
  }
  return -1;
}

function bufToHex(element) {
  return Buffer.isBuffer(element) ? '0x' + element.toString('hex') : element;
}

function bufJoin() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return Buffer.concat([...args]);
}

function bufSortJoin() {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return Buffer.concat([...args].sort(Buffer.compare));
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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a0MsR0FBbEMsRUFBdUM7QUFDckMsUUFBSSxRQUFRLE1BQVIsQ0FBZSxNQUFNLENBQU4sQ0FBZixDQUFKLEVBQThCO0FBQUUsYUFBTyxDQUFQO0FBQVU7QUFDM0M7QUFDRCxTQUFPLENBQUMsQ0FBUjtBQUNEOztBQUVELFNBQVMsUUFBVCxDQUFrQixPQUFsQixFQUEyQjtBQUN6QixTQUFPLE9BQU8sUUFBUCxDQUFnQixPQUFoQixJQUEyQixPQUFPLFFBQVEsUUFBUixDQUFpQixLQUFqQixDQUFsQyxHQUE0RCxPQUFuRTtBQUNEOztBQUVELFNBQVMsT0FBVCxHQUEwQjtBQUFBLG9DQUFOLElBQU07QUFBTixRQUFNO0FBQUE7O0FBQ3hCLFNBQU8sT0FBTyxNQUFQLENBQWMsQ0FBQyxHQUFHLElBQUosQ0FBZCxDQUFQO0FBQ0Q7O0FBRUQsU0FBUyxXQUFULEdBQThCO0FBQUEscUNBQU4sSUFBTTtBQUFOLFFBQU07QUFBQTs7QUFDNUIsU0FBTyxPQUFPLE1BQVAsQ0FBYyxDQUFDLEdBQUcsSUFBSixFQUFVLElBQVYsQ0FBZSxPQUFPLE9BQXRCLENBQWQsQ0FBUDtBQUNEIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL3JhaWRlbi1uZXR3b3JrL3JhaWRlbi9ibG9iL21hc3Rlci9yYWlkZW4vbXRyZWUucHlcbi8vIENyZWF0ZSBhIG1lcmtsZSByb290IGZyb20gYSBsaXN0IG9mIGVsZW1lbnRzXG4vLyBFbGVtZW50cyBhcmUgYXNzdW1lZCB0byBiZSAzMiBieXRlcyBoYXNoZXMgKEJ1ZmZlcnMpXG4vLyAgKGJ1dCBtYXkgYmUgZXhwcmVzc2VkIGFzIDB4IHByZWZpeGVkIGhleCBzdHJpbmdzIG9mIGxlbmd0aCA2Nilcbi8vIFRoZSBib3R0b20gbGF5ZXIgb2YgdGhlIHRyZWUgKGxlYWYgbm9kZXMpIGFyZSB0aGUgZWxlbWVudHNcbi8vIEFsbCBsYXllcnMgYWJvdmUgYXJlIGNvbWJpbmVkIGhhc2hlcyBvZiB0aGUgZWxlbWVudCBwYWlyc1xuXG4vLyBUd28gc3RyYXRlZ2llcyBmb3IgY3JlYXRpbmcgdHJlZSBhbmQgY2hlY2tpbmcgcHJvb2ZzIChwcmVzZXJ2ZU9yZGVyIGZsYWcpXG4vLyAxLiByYWlkZW4gLSBzb3J0IHRoZSBsZWF2ZXMgb2YgdGhlIHRyZWUsIGFuZCBhbHNvIHNvcnQgZWFjaCBwYWlyIG9mXG4vLyAgICBwcmUtaW1hZ2VzLCB3aGljaCBhbGxvd3MgeW91IHRvIHZlcmlmeSB0aGUgcHJvb2Ygd2l0aG91dCB0aGUgaW5kZXhcbi8vIDIuIHN0b3JqIC0gcHJlc2VydmUgdGhlIG9yZGVyIG9mIHRoZSBsZWF2ZXMgYW5kIHBhaXJzIG9mIHByZS1pbWFnZXMsIGFuZCB1c2Vcbi8vICAgIHRoZSBpbmRleCB0byB2ZXJpZnkgdGhlIHByb29mXG5cbi8vIFRoZSBNZXJrbGVUcmVlIGlzIGEgMmQgYXJyYXkgb2YgbGF5ZXJzXG4vLyBbIGVsZW1lbnRzLCBjb21iaW5lZEhhc2hlczEsIGNvbWJpbmVkSGFzaGVzMiwgLi4uIHJvb3RdXG4vLyByb290IGlzIGEgbGVuZ3RoIDEgYXJyYXlcblxuaW1wb3J0IHsgc2hhMyB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbCdcblxuLy8gRXhwZWN0cyBlbGVtZW50cyB0byBiZSBCdWZmZXJzIG9mIGxlbmd0aCAzMlxuLy8gZW1wdHkgc3RyaW5nIGVsZW1lbnRzIHdpbGwgYmUgcmVtb3ZlZCBwcmlvciB0byB0aGUgYnVmZmVyIGNoZWNrXG4vLyBieSBkZWZhdWx0LCBvcmRlciBpcyBub3QgcHJlc2VydmVkXG5mdW5jdGlvbiBNZXJrbGVUcmVlKGVsZW1lbnRzLCBwcmVzZXJ2ZU9yZGVyKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNZXJrbGVUcmVlKSkge1xuICAgIHJldHVybiBuZXcgTWVya2xlVHJlZShlbGVtZW50cywgcHJlc2VydmVPcmRlcilcbiAgfVxuXG4gIHRoaXMuZWxlbWVudHMgPSBBcnJheS5mcm9tKG5ldyBTZXQoZWxlbWVudHMuZmlsdGVyKGEgPT4gYSkpKVxuICBpZiAodGhpcy5lbGVtZW50cy5zb21lKChlKSA9PiAhKGUubGVuZ3RoID09IDMyICYmIEJ1ZmZlci5pc0J1ZmZlcihlKSkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbGVtZW50cyBtdXN0IGJlIDMyIGJ5dGUgYnVmZmVycycpXG4gIH1cbiAgdGhpcy5wcmVzZXJ2ZU9yZGVyID0gISFwcmVzZXJ2ZU9yZGVyXG4gIGlmICghdGhpcy5wcmVzZXJ2ZU9yZGVyKSB7XG4gICAgdGhpcy5lbGVtZW50cy5zb3J0KEJ1ZmZlci5jb21wYXJlKVxuICB9XG4gIHRoaXMubGF5ZXJzID0gZ2V0TGF5ZXJzKHRoaXMuZWxlbWVudHMsIHRoaXMucHJlc2VydmVPcmRlcilcbn1cblxuTWVya2xlVHJlZS5wcm90b3R5cGUuZ2V0Um9vdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5sYXllcnNbdGhpcy5sYXllcnMubGVuZ3RoIC0gMV1bMF1cbn1cblxuTWVya2xlVHJlZS5wcm90b3R5cGUuZ2V0UHJvb2YgPSBmdW5jdGlvbihlbGVtZW50LCBoZXgpIHtcbiAgY29uc3QgaW5kZXggPSBnZXRCdWZJbmRleChlbGVtZW50LCB0aGlzLmVsZW1lbnRzKVxuICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgbm90IGZvdW5kIGluIG1lcmtsZSB0cmVlJylcbiAgfVxuICByZXR1cm4gZ2V0UHJvb2YoaW5kZXgsIHRoaXMubGF5ZXJzLCBoZXgpXG59XG5cbmNvbnN0IGNoZWNrUHJvb2ZPcmRlcmVkID0gZnVuY3Rpb24ocHJvb2YsIHJvb3QsIGVsZW1lbnQsIGluZGV4KSB7XG4gIC8vIHVzZSB0aGUgaW5kZXggdG8gZGV0ZXJtaW5lIHRoZSBub2RlIG9yZGVyaW5nXG4gIC8vIGluZGV4IHJhbmdlcyAxIHRvIG5cblxuICBsZXQgdGVtcEhhc2ggPSBlbGVtZW50XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9vZi5sZW5ndGg7IGkrKykge1xuICAgIGxldCByZW1haW5pbmcgPSBwcm9vZi5sZW5ndGggLSBpXG5cbiAgICAvLyB3ZSBkb24ndCBhc3N1bWUgdGhhdCB0aGUgdHJlZSBpcyBwYWRkZWQgdG8gYSBwb3dlciBvZiAyXG4gICAgLy8gaWYgdGhlIGluZGV4IGlzIG9kZCB0aGVuIHRoZSBwcm9vZiB3aWxsIHN0YXJ0IHdpdGggYSBoYXNoIGF0IGEgaGlnaGVyXG4gICAgLy8gbGF5ZXIsIHNvIHdlIGhhdmUgdG8gYWRqdXN0IHRoZSBpbmRleCB0byBiZSB0aGUgaW5kZXggYXQgdGhhdCBsYXllclxuICAgIHdoaWxlIChyZW1haW5pbmcgJiYgaW5kZXggJSAyID09PSAxICYmIGluZGV4ID4gTWF0aC5wb3coMiwgcmVtYWluaW5nKSkge1xuICAgICAgaW5kZXggPSBNYXRoLnJvdW5kKGluZGV4IC8gMilcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggJSAyID09PSAwKSB7XG4gICAgICB0ZW1wSGFzaCA9IGNvbWJpbmVkSGFzaChwcm9vZltpXSwgdGVtcEhhc2gsIHRydWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXBIYXNoID0gY29tYmluZWRIYXNoKHRlbXBIYXNoLCBwcm9vZltpXSwgdHJ1ZSlcbiAgICB9XG4gICAgaW5kZXggPSBNYXRoLnJvdW5kKGluZGV4IC8gMilcbiAgfVxuXG4gIHJldHVybiB0ZW1wSGFzaC5lcXVhbHMocm9vdClcbn1cblxuY29uc3QgY2hlY2tQcm9vZiA9IGZ1bmN0aW9uKHByb29mLCByb290LCBlbGVtZW50KSB7XG4gIHJldHVybiByb290LmVxdWFscyhwcm9vZi5yZWR1Y2UoKGhhc2gsIHBhaXIpID0+IHtcbiAgICByZXR1cm4gY29tYmluZWRIYXNoKGhhc2gsIHBhaXIpXG4gIH0sIGVsZW1lbnQpKVxufVxuXG5jb25zdCBtZXJrbGVSb290ID0gZnVuY3Rpb24oZWxlbWVudHMsIHByZXNlcnZlT3JkZXIpIHtcbiAgcmV0dXJuIChuZXcgTWVya2xlVHJlZShlbGVtZW50cywgcHJlc2VydmVPcmRlcikpLmdldFJvb3QoKVxufVxuXG4vLyBjb252ZXJ0cyBidWZmZXJzIGZyb20gTWVya2xlUm9vdCBmdW5jdGlvbnMgaW50byBoZXggc3RyaW5nc1xuLy8gbWVya2xlUHJvb2YgaXMgdGhlIGNvbnRyYWN0IGFic3RyYWN0aW9uIGZvciBNZXJrbGVQcm9vZi5zb2xcbmNvbnN0IGNoZWNrUHJvb2ZTb2xpZGl0eUZhY3RvcnkgPSBmdW5jdGlvbihjaGVja1Byb29mQ29udHJhY3RNZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHByb29mLCByb290LCBoYXNoKSB7XG4gICAgcHJvb2YgPSAnMHgnICsgcHJvb2YubWFwKGUgPT4gZS50b1N0cmluZygnaGV4JykpLmpvaW4oJycpXG4gICAgcm9vdCA9IGJ1ZlRvSGV4KHJvb3QpXG4gICAgaGFzaCA9IGJ1ZlRvSGV4KGhhc2gpXG4gICAgcmV0dXJuIGNoZWNrUHJvb2ZDb250cmFjdE1ldGhvZChwcm9vZiwgcm9vdCwgaGFzaClcbiAgfVxufVxuXG5jb25zdCBjaGVja1Byb29mT3JkZXJlZFNvbGlkaXR5RmFjdG9yeSA9IGZ1bmN0aW9uKGNoZWNrUHJvb2ZPcmRlcmVkQ29udHJhY3RNZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHByb29mLCByb290LCBoYXNoLCBpbmRleCkge1xuICAgIHByb29mID0gJzB4JyArIHByb29mLm1hcChlID0+IGUudG9TdHJpbmcoJ2hleCcpKS5qb2luKCcnKVxuICAgIHJvb3QgPSBidWZUb0hleChyb290KVxuICAgIGhhc2ggPSBidWZUb0hleChoYXNoKVxuICAgIHJldHVybiBjaGVja1Byb29mT3JkZXJlZENvbnRyYWN0TWV0aG9kKHByb29mLCByb290LCBoYXNoLCBpbmRleClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNZXJrbGVUcmVlXG5leHBvcnQgeyBjaGVja1Byb29mLCBjaGVja1Byb29mT3JkZXJlZCwgbWVya2xlUm9vdCwgY2hlY2tQcm9vZlNvbGlkaXR5RmFjdG9yeSxcbiAgY2hlY2tQcm9vZk9yZGVyZWRTb2xpZGl0eUZhY3Rvcnlcbn1cblxuZnVuY3Rpb24gY29tYmluZWRIYXNoKGZpcnN0LCBzZWNvbmQsIHByZXNlcnZlT3JkZXIpIHtcbiAgaWYgKCFzZWNvbmQpIHsgcmV0dXJuIGZpcnN0IH1cbiAgaWYgKCFmaXJzdCkgeyByZXR1cm4gc2Vjb25kIH1cbiAgaWYgKHByZXNlcnZlT3JkZXIpIHtcbiAgICByZXR1cm4gc2hhMyhidWZKb2luKGZpcnN0LCBzZWNvbmQpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzaGEzKGJ1ZlNvcnRKb2luKGZpcnN0LCBzZWNvbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldE5leHRMYXllcihlbGVtZW50cywgcHJlc2VydmVPcmRlcikge1xuICByZXR1cm4gZWxlbWVudHMucmVkdWNlKChsYXllciwgZWxlbWVudCwgaW5kZXgsIGFycikgPT4ge1xuICAgIGlmIChpbmRleCAlIDIgPT0gMCkgeyBsYXllci5wdXNoKGNvbWJpbmVkSGFzaChlbGVtZW50LCBhcnJbaW5kZXggKyAxXSwgcHJlc2VydmVPcmRlcikpIH1cbiAgICByZXR1cm4gbGF5ZXJcbiAgfSwgW10pXG59XG5cbmZ1bmN0aW9uIGdldExheWVycyhlbGVtZW50cywgcHJlc2VydmVPcmRlcikge1xuICBpZiAoZWxlbWVudHMubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm4gW1snJ11dXG4gIH1cbiAgY29uc3QgbGF5ZXJzID0gW11cbiAgbGF5ZXJzLnB1c2goZWxlbWVudHMpXG4gIHdoaWxlIChsYXllcnNbbGF5ZXJzLmxlbmd0aCAtIDFdLmxlbmd0aCA+IDEpIHtcbiAgICBsYXllcnMucHVzaChnZXROZXh0TGF5ZXIobGF5ZXJzW2xheWVycy5sZW5ndGggLSAxXSwgcHJlc2VydmVPcmRlcikpXG4gIH1cbiAgcmV0dXJuIGxheWVyc1xufVxuXG5mdW5jdGlvbiBnZXRQcm9vZihpbmRleCwgbGF5ZXJzLCBoZXgpIHtcbiAgY29uc3QgcHJvb2YgPSBsYXllcnMucmVkdWNlKChwcm9vZiwgbGF5ZXIpID0+IHtcbiAgICBsZXQgcGFpciA9IGdldFBhaXIoaW5kZXgsIGxheWVyKVxuICAgIGlmIChwYWlyKSB7IHByb29mLnB1c2gocGFpcikgfVxuICAgIGluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIDIpXG4gICAgcmV0dXJuIHByb29mXG4gIH0sIFtdKVxuICBpZiAoaGV4KSB7XG4gICAgcmV0dXJuICcweCcgKyBwcm9vZi5tYXAoZSA9PiBlLnRvU3RyaW5nKCdoZXgnKSkuam9pbignJylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJvb2ZcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQYWlyKGluZGV4LCBsYXllcikge1xuICBsZXQgcGFpckluZGV4ID0gaW5kZXggJSAyID8gaW5kZXggLSAxIDogaW5kZXggKyAxXG4gIGlmIChwYWlySW5kZXggPCBsYXllci5sZW5ndGgpIHtcbiAgICByZXR1cm4gbGF5ZXJbcGFpckluZGV4XVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QnVmSW5kZXgoZWxlbWVudCwgYXJyYXkpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlbGVtZW50LmVxdWFscyhhcnJheVtpXSkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG5mdW5jdGlvbiBidWZUb0hleChlbGVtZW50KSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoZWxlbWVudCkgPyAnMHgnICsgZWxlbWVudC50b1N0cmluZygnaGV4JykgOiBlbGVtZW50XG59XG5cbmZ1bmN0aW9uIGJ1ZkpvaW4oLi4uYXJncykge1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbLi4uYXJnc10pXG59XG5cbmZ1bmN0aW9uIGJ1ZlNvcnRKb2luKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoWy4uLmFyZ3NdLnNvcnQoQnVmZmVyLmNvbXBhcmUpKVxufVxuXG4iXX0=